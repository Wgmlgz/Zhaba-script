use 'std.zh'
use 'util.zh' // for rand and sleep
use './canvas.zh'
use 'range.zh'

/**
Max compression:

fn main: w:=30 h:=30 c:=newCnv(w h) r:=54 d:=asch('.') l:=asch('#') c.fill(d)
  @i 0..c.h: @ j 0..c.w: ?rng() as int%2: *c.at(i j)=l
  @k 0..500: nc:=newCnv(w h) nc.fill(d)
    @i 1..c.h-1: @ j 1..c.h-1: n:=0
      @x, -1..2: @ y, -1..2: ? !(y==0&&x==0)&&c.get(i+x j+y)==l: &n+=1
      ? *c.at(i j)==l&&n==2||n==3: *nc.at(i j)=l
      | n==3: *nc.at(i j)=l
    c = nc, cls(), out &c, sleep(50)

*/

fn main
  w := 30 h := 30
  c := newCnv(w h)
  r := 54
  dead := asch('.') live := asch('#')
  c.fill(dead)

  @ i 0..c.h
    @ j 0..c.w
      ? rng() as int % 2
        *c.at(i j) = live

  @ k 0..500
    nc := newCnv(w h)
    nc.fill(dead)
    
    @ i 1..c.h-1
      @ j 1..c.h-1:
        near := 0
        @ x, -1..2
          @ y, -1..2
            ? !(y == 0 && x == 0) && c.get(i+x j+y) == live
              &near += 1

        ? *c.at(i j) == live && near == 2 || near == 3: *nc.at(i j) = live
        | near == 3: *nc.at(i j) = live

    c = nc
    cls()
    out &c
    sleep(50)

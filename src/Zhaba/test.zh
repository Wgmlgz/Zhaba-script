include 'std.zh'
include 'vec.zh'
include 'range.zh'
include 'util.zh'

op 9 int < char a char b: <<< a as int < b as int

impl Vec
  fn swap TP a TP b
    T t = *a
    *a = *b
    *b = t

  fn int get_item_size
    T item
    int item_size
    #'item_size = sizeof(item)'
    <<< item_size

  fn next_ptr TPP ptr: *ptr = (*ptr as int + slf.get_item_size()) as TP
  fn prev_ptr TPP ptr: *ptr = (*ptr as int - slf.get_item_size()) as TP
  
  fn int ptr_uneq TP a TP b
    <<< a as int != b as int

  fn TP partition TP low TP high
    slf.prev_ptr(&high)
    TP pivot = high i = low j = low
    TP i = low

    @ (j = low) (slf.ptr_uneq(j pivot)) (slf.next_ptr(&j))
      ? *j < *pivot
        slf.swap(i j)
        slf.next_ptr(&i)

    slf.swap(i  pivot)
    <<< i

  fn qsort TP lhs TP rhs
    ? rhs as int - lhs as int > 8
      auto pi = slf.partition(lhs rhs)
      slf.qsort(lhs pi)
      slf.next_ptr(&pi)
      slf.qsort(pi rhs)
  
  fn sort
    slf.qsort(slf.begin() slf.end())

fn main
  Vec<int> a
  a.ctor()
  auto r = 0..20
  @ r.nxt(): a.push_back(rng() % 10)
  out 'Vec<int> sort:'
  a.print()
  a.sort()
  a.print()
  a.dtor()

  Vec<char> b
  b.ctor()
  r = 0..20
  @ r.nxt(): b.push_back((rng() % 26 + aschar('a') as int) as char)
  out 'Vec<char> sort:'
  b.print()
  b.sort()
  b.print()
  b.dtor()

use range
use operators

type Vec T: int size; 
  int capacity
  TP head

type VecIter T: TP ptr

impl VecIter
  fn next
    slf.ptr = slf.ptr + 1
  fn bool uneq VecIter<T> other
    <<< slf.ptr != other.ptr
  lop TR * VecIter<T> slf
    <<< *slf.ptr
  fn TR get
    <<< *slf.ptr

impl Vec
  fn free_mem
    // ? ! !(slf.head as int): free(slf.head as int)
    slf.size = 0
    slf.capacity = 0
    slf.head = 0 as TP

  fn TP atP int pos: <<< (slf.head + pos) as TP
  fn TR at int pos: <<< *slf.atP(pos)
    
  fn print
    int i = 0
    put('[')
    @ i 0..slf.size
     ? ! !i: put(' ')
     put(*slf.atP(i))
    out(']')

  fn double_capacity
    new_capacity := slf.capacity
    ? new_capacity == 0
      new_capacity = 1
      slf.head = malloc(sizeof T) as TP
      slf.capacity = new_capacity
    \ new_capacity *= 2
      new_head := malloc(new_capacity * sizeof T) as TP
      @ i 0..slf.size: *(new_head + i) = slf.at(i)
      //TODO fix free 
      // free(slf.head as int)
      slf.head = new_head
    slf.capacity = new_capacity

  fn push_back T val
    ? slf.size == slf.capacity: slf.double_capacity()
    slf.at(slf.size) = val
    ++slf.size

  op 16 += Vec<T>P slf T val: slf.push_back(val)
    
  fn pop_back: --slf.size
  
  fn VecIter<T> begin: <<< slf.head as VecIter<T> 
  fn VecIter<T> end: <<< slf.atP(slf.size) as VecIter<T>
  fn T front: <<< *slf.head
  fn T back: <<< *slf.atP(slf.size-1)
  fn TP frontP: <<< slf.head
  fn TP backP: <<< slf.atP(slf.size-1)

  fn dtor: slf.free_mem()
  fn ctor int size
    Vec<T> slf
    slf.head = 0 as TP
    slf.size = 0
    slf.capacity = 0
    @ slf.capacity < size: slf.double_capacity()
    slf.size = size
    slf.capacity = size
  
  fn ctor
    Vec<T> slf
    <<< Vec<T>(0)

  fn ctor Vec<T>R other
    out 'copy!'
    slf := Vec<T>(other.size)
    @ i 0..other.size: slf.at(i) = other.at(i)
    <<< slf

  fn Vec<T> sub int begin int end
    res := Vec<T>(0)
    @ i begin..end: res.push_back(slf.at(i))
    <<< res

  fn swap TP a TP b
    T t = *a
    *a = *b
    *b = t

  fn next_ptr TPP ptr: *ptr = (*ptr as int + sizeof(T)) as TP
  fn prev_ptr TPP ptr: *ptr = (*ptr as int - sizeof(T)) as TP
  
  fn TP partition TP low TP high
    slf.prev_ptr(&high)
    TP pivot = high i = low j = low

    @ j = low, j != pivot, slf.next_ptr(&j)
      ? *j < *pivot
        slf.swap(i j)
        slf.next_ptr(&i)

    slf.swap(i  pivot)
    <<< i

  fn qsort TP lhs TP rhs
    a := rhs as int - lhs as int
    b := sizeof(T)
    ? a > b
      auto pi = slf.partition(lhs rhs)
      slf.qsort(lhs pi)
      slf.next_ptr(&pi)
      slf.qsort(pi rhs)
  
  // fn sort: slf.qsort(slf.begin() slf.end())

fn Vec<int> iota int begin int end
  v := Vec<int>(end - begin)
  @ i begin..end: v.at(i - begin) = i
  <<< v

use range
use operators
use out
use util

type Vec T
  int size 
  int cap
  TP head

type VecIter T: TP ptr

impl VecIter
  fn ctor TP ptr: VecIter<T> slf; slf.ptr = ptr; <<< slf
  fn next: slf.ptr = slf.ptr + 1
  fn bool uneq VecIter<T> other: <<< slf.ptr != other.ptr
  lop TR * VecIter<T> slf: <<< *slf.ptr

impl Vec
  fn TP atP int pos: <<< (slf.head + pos) as TP
  fn TR at int pos: <<< *slf.atP(pos)
    
  fn print
    put '['
    @ i 0..slf.size
      ? ! !i: put ' '
      put (*slf.atP(i))
    put ']'

  fn println: @ i 0..slf.size: out (*slf.atP(i))
  
  fn double_cap
    ncap := slf.cap
    ? ncap == 0
      ncap = 1
      slf.head = malloc(sizeof T) as TP
      slf.cap = ncap
    \ ncap *= 2
      new_head := malloc(ncap * sizeof T) as TP
      @ i 0..slf.size: *(new_head + i) = slf.at(i)
      free(slf.head as int)
      slf.head = new_head
    slf.cap = ncap

  fn push_back T val
    ? slf.size == slf.cap: slf.double_cap()
    slf.at(slf.size) = val
    ++slf.size
    
  fn pop_back: --slf.size
  
  fn VecIter<T> begin: <<< VecIter<T>(slf.head) 
  fn VecIter<T> end: <<< VecIter<T>(slf.atP(slf.size))
  fn TR front: <<< *slf.head
  fn TR back: <<< *slf.atP(slf.size-1)

  fn dtor
    ? ! !(slf.head as int)
      free(slf.head as int)
      slf.size = 0
      slf.cap = 0
      slf.head = 0 as TP

  /** Constructors */
  fn ctor int size
    Vec<T> slf
    slf.head = 0 as TP
    slf.size = 0
    slf.cap = 0
    @ slf.cap < size: slf.double_cap()
    slf.size = size
    slf.cap = size

    @ i 0..slf.size: slf.at(i) = T()
    <<< slf
    
  fn ctor int size T default
    slf := Vec<T>(size)
    @ i 0..slf.size: slf.at(i) = default
    <<< slf

  fn ctor: <<< Vec<T>(0)

  fn ctor Vec<T>R other
    slf := Vec<T>(other.size)
    @ i 0..other.size: slf.at(i) = other.at(i)
    <<< slf

  /**  Overloaded operators */
  op 16 += Vec<T>R slf T val: slf.push_back(val)
  op 16 += Vec<T>R slf Vec<T>R other
    @ i other: slf.push_back(*i)

  op 2 Vec<T> ,, T a T b
    Vec<T> slf
    slf += a
    slf += b
    <<< slf
  op 2 Vec<T>R ,, Vec<T>R v T a
    v += a
    <<< v

  /** Output overload */
  lop put Vec<T>R slf: slf.print()
  lop out Vec<T>R slf: slf.print(); out ''
  rop Out < Vec<T>R i: out i
    <<< Out()
  lop Out < Vec<T>R i: put i, put ' '
    <<< Out()
  op 9 Out < Out o Vec<T>R i: put i, put ' '
    <<< Out()

  /** Subscripts */
  fn TR sub int id
    ? id < 0: id += slf.size
    <<< slf.at(id)

  fn Vec<T> sub int begin int end
    res := Vec<T>(0)
    @ i begin..end: res.push_back(slf.at(i))
    <<< res

  fn Vec<T> sub Range r
    begin := r.begin end := r.end
    ? begin < 0: begin += slf.size
    ? begin < 0: begin = 0
    ? end < 0: end += slf.size
    ? end > slf.size: end = slf.size
    <<< slf[begin end]

  fn Vec<T> sub: <<< slf[0 slf.size]

  /** Sorting */
  op 9 bool < Vec<T>R a Vec<T>R b
    <<< false

  lop swap TP a TP b: T t = *a; *a = *b; *b = t

  lop TP partition TP low TP high
    pivot := high - 1 i := low j := low
    @ j = low j != pivot j = j + 1
      ? *j < *pivot: swap(i j); i = i + 1
    swap(i  pivot)
    <<< i

  lop qsort TP lhs TP rhs
    a := rhs as int - lhs as int
    b := sizeof(T)
    ? a > b
      pi := partition(lhs rhs)
      qsort(lhs pi)
      pi = pi + 1
      qsort(pi rhs)
  
  fn sort: qsort(slf.begin().ptr slf.end().ptr)
  lop sort Vec<T>R slf: slf.sort()

/** Util */
fn Vec<int> iota int begin int end
  v := Vec<int>(end - begin)
  @ i begin..end: v.at(i - begin) = i
  <<< v

impl Range
  fn Vec<int> call
    res := Vec<int>()
    @ i, *slf: res += i
    <<< res
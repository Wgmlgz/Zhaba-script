use range
use operators

type Vec T
  int size
  int capacity
  TP head

impl Vec
  fn free_mem
    // ? ! !(slf.head as int): free(slf.head as int)
    slf.size = 0
    slf.capacity = 0
    slf.head = 0 as TP

  fn TP atP int pos
    <<< (((slf.head) as int) + pos * sizeof T) as TP

  fn T at int pos: <<< *slf.atP(pos)
    
  fn double_capacity
    new_capacity := slf.capacity
    ? new_capacity == 0
      new_capacity = 1
      slf.head = malloc(sizeof T) as TP
      slf.capacity = new_capacity
    \ new_capacity *= 2
      new_head := malloc(new_capacity * sizeof T) as TP
      @ i 0..slf.size: *(new_head + i) = slf.at(i)
      //TODO fix free 
      // free(slf.head as int)
      slf.head = new_head
    slf.capacity = new_capacity

  fn push_back T val
    ? slf.size == slf.capacity: slf.double_capacity()
    *slf.atP(slf.size) = val
    ++slf.size
  fn pop_back: --slf.size
  
  fn TP begin: <<< slf.head
  fn TP end: <<< slf.atP(slf.size)
  fn T front: <<< *slf.head
  fn T back: <<< *slf.atP(slf.size-1)
  fn TP frontP: <<< slf.head
  fn TP backP: <<< slf.atP(slf.size-1)

  fn dtor: slf.free_mem()
  fn ctor int size
    slf.head = 0 as TP
    slf.size = 0
    slf.capacity = 0
    @ slf.capacity < size: slf.double_capacity()
    slf.size = size
  
  fn ctor: slf.ctor(0)

  fn print
    int i = 0
    put('[')
    @ i 0..slf.size
     ? ! !i: put(' ')
     put(slf.at(i))
    out(']')

impl Vec
  fn swap TP a TP b
    T t = *a
    *a = *b
    *b = t

  fn next_ptr TPP ptr: *ptr = (*ptr as int + sizeof(T)) as TP
  fn prev_ptr TPP ptr: *ptr = (*ptr as int - sizeof(T)) as TP
  
  fn TP partition TP low TP high
    slf.prev_ptr(&high)
    TP pivot = high i = low j = low
    TP i = low

    @ j = low, j != pivot, slf.next_ptr(&j)
      ? *j < *pivot
        slf.swap(i j)
        slf.next_ptr(&i)

    slf.swap(i  pivot)
    <<< i

  fn qsort TP lhs TP rhs
    a := rhs as int - lhs as int
    b := sizeof(T)
    ? a > b
      auto pi = slf.partition(lhs rhs)
      slf.qsort(lhs pi)
      slf.next_ptr(&pi)
      slf.qsort(pi rhs)
  
  fn sort: slf.qsort(slf.begin() slf.end())
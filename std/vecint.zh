// slassic vector for i64
type VecInt
  int size
  int capacity
  intP head

impl VecInt
  fn free_mem
    ? slf.head as int: free(slf.head as int)
    slf.size = 0
    slf.capacity = 0
    slf.head = 0 as intP
  
  fn double_capacity
    auto new_capacity = slf.capacity
    ? new_capacity == 0
      new_capacity = 1
      slf.head = malloc(1 * 8) as intP
    \ &new_capacity *= 2
      slf.head = realloc(slf.head as int, new_capacity * 8) as intP
    slf.capacity = new_capacity

  fn intP atP int pos
    <<< (((slf.head) as int) + pos * 8) as intP

  fn int at int pos
    <<< *slf.atP(pos)
  
  fn push_back int val
    ? slf.size == slf.capacity: slf.double_capacity()
    *slf.atP(slf.size) = val
    &slf.size += 1
  
  fn intP begin: <<< slf.head
  fn intP end: <<< slf.atP(slf.size)
  fn int front: <<< *slf.head
  fn int back: <<< *slf.atP(slf.size-1)
  fn intP frontP: <<< slf.head
  fn intP backP: <<< slf.atP(slf.size-1)

  fn dtor: slf.free_mem()

fn VecInt newVecInt int size
  VecInt slf
  slf.head = 0 as intP
  slf.size = 0
  slf.capacity = 0
  @ slf.capacity < size: slf.double_capacity()
  slf.size = size

fn VecInt newVecInt
  <<< newVecInt(0)

lop out VecIntP vec
  int i = 0
  put('[')
  @ i=0 i<(vec.size) (&i += 1)
   ? i: put(' ')
   put(vec.at(i))
  out(']')

lop deb VecIntP vec
  put('size: ')
  out(vec.size)

  put('capacity: ')
  out(vec.capacity)

  put('head: ')
  out(vec.head as u64)

  put('content: ')
  out(vec)
